/* eslint-disable @typescript-eslint/no-redeclare */
export type Maybe<T> = T | null;
export type InputMaybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Cursor: { input: string; output: string; }
  Time: { input: string; output: string; }
};

export type AuthPayload = {
  accessToken: Scalars['String']['output'];
  refreshToken: Scalars['String']['output'];
  user: User;
};

export type CreateProfileInput = {
  name: Scalars['String']['input'];
  sourceFile: Scalars['String']['input'];
  title: Scalars['String']['input'];
  urn: Scalars['String']['input'];
};

export type CreateTodoInput = {
  name: Scalars['String']['input'];
  priority: Scalars['Int']['input'];
  status?: InputMaybe<TodoStatus>;
  userID: Scalars['ID']['input'];
};

export type CreateUserInput = {
  age: Scalars['Int']['input'];
  email: Scalars['String']['input'];
  name: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

export type LoginInput = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

export type Mutation = {
  createProfile: Profile;
  createTodo: Todo;
  createUser: User;
  login: Maybe<AuthPayload>;
  refreshToken: Maybe<RefreshTokenPayload>;
  updateProfile: Profile;
  updateTodo: Todo;
  updateUser: User;
};


export type MutationCreateProfileArgs = {
  input: CreateProfileInput;
};


export type MutationCreateTodoArgs = {
  input: CreateTodoInput;
};


export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


export type MutationLoginArgs = {
  input: LoginInput;
};


export type MutationUpdateProfileArgs = {
  input: UpdateProfileInput;
};


export type MutationUpdateTodoArgs = {
  input: UpdateTodoInput;
};


export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};

export type Node = {
  id: Scalars['ID']['output'];
};

export type PageInfo = {
  endCursor: Maybe<Scalars['Cursor']['output']>;
  hasNextPage: Scalars['Boolean']['output'];
  hasPreviousPage: Scalars['Boolean']['output'];
  startCursor: Maybe<Scalars['Cursor']['output']>;
};

export type Profile = Node & {
  createdAt: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  sourceFile: Scalars['String']['output'];
  title: Scalars['String']['output'];
  updatedAt: Scalars['String']['output'];
  urn: Scalars['String']['output'];
};

export type ProfileConnection = {
  edges: Maybe<Array<Maybe<ProfileEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type ProfileEdge = {
  cursor: Scalars['Cursor']['output'];
  node: Maybe<Profile>;
};

export type ProfileTitleGroup = {
  count: Scalars['Int']['output'];
  title: Scalars['String']['output'];
};

/**
 * ProfileWhereInput is used for filtering Profile objects.
 * Input was generated by ent.
 */
export type ProfileWhereInput = {
  and?: InputMaybe<Array<ProfileWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** todos edge predicates */
  hasTodos?: InputMaybe<Scalars['Boolean']['input']>;
  hasTodosWith?: InputMaybe<Array<TodoWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ProfileWhereInput>;
  or?: InputMaybe<Array<ProfileWhereInput>>;
  /** source_file field predicates */
  sourceFile?: InputMaybe<Scalars['String']['input']>;
  sourceFileContains?: InputMaybe<Scalars['String']['input']>;
  sourceFileContainsFold?: InputMaybe<Scalars['String']['input']>;
  sourceFileEqualFold?: InputMaybe<Scalars['String']['input']>;
  sourceFileGT?: InputMaybe<Scalars['String']['input']>;
  sourceFileGTE?: InputMaybe<Scalars['String']['input']>;
  sourceFileHasPrefix?: InputMaybe<Scalars['String']['input']>;
  sourceFileHasSuffix?: InputMaybe<Scalars['String']['input']>;
  sourceFileIn?: InputMaybe<Array<Scalars['String']['input']>>;
  sourceFileLT?: InputMaybe<Scalars['String']['input']>;
  sourceFileLTE?: InputMaybe<Scalars['String']['input']>;
  sourceFileNEQ?: InputMaybe<Scalars['String']['input']>;
  sourceFileNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** urn field predicates */
  urn?: InputMaybe<Scalars['String']['input']>;
  urnContains?: InputMaybe<Scalars['String']['input']>;
  urnContainsFold?: InputMaybe<Scalars['String']['input']>;
  urnEqualFold?: InputMaybe<Scalars['String']['input']>;
  urnGT?: InputMaybe<Scalars['String']['input']>;
  urnGTE?: InputMaybe<Scalars['String']['input']>;
  urnHasPrefix?: InputMaybe<Scalars['String']['input']>;
  urnHasSuffix?: InputMaybe<Scalars['String']['input']>;
  urnIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urnLT?: InputMaybe<Scalars['String']['input']>;
  urnLTE?: InputMaybe<Scalars['String']['input']>;
  urnNEQ?: InputMaybe<Scalars['String']['input']>;
  urnNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type Query = {
  node: Maybe<Node>;
  profile: Maybe<Profile>;
  profiles: Maybe<ProfileConnection>;
  profilesByTitle: Array<ProfileTitleGroup>;
  todo: Maybe<Todo>;
  todos: Maybe<TodoConnection>;
  user: Maybe<User>;
  users: Maybe<UserConnection>;
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryProfileArgs = {
  input?: InputMaybe<ProfileWhereInput>;
};


export type QueryProfilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ProfileWhereInput>;
};


export type QueryProfilesByTitleArgs = {
  minCount: Scalars['Int']['input'];
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTodoArgs = {
  input?: InputMaybe<TodoWhereInput>;
};


export type QueryTodosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<TodoWhereInput>;
};


export type QueryUserArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserWhereInput>;
};

export type RefreshTokenPayload = {
  accessToken: Scalars['String']['output'];
  refreshToken: Scalars['String']['output'];
};

export type Todo = Node & {
  createdAt: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  priority: Scalars['Int']['output'];
  status: TodoStatus;
  updatedAt: Scalars['String']['output'];
  userID: Maybe<Scalars['ID']['output']>;
};

export type TodoConnection = {
  edges: Maybe<Array<Maybe<TodoEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type TodoEdge = {
  cursor: Scalars['Cursor']['output'];
  node: Maybe<Todo>;
};

export const TodoStatus = {
  Completed: 'COMPLETED',
  InProgress: 'IN_PROGRESS'
} as const;

export type TodoStatus = typeof TodoStatus[keyof typeof TodoStatus];
/**
 * TodoWhereInput is used for filtering Todo objects.
 * Input was generated by ent.
 */
export type TodoWhereInput = {
  and?: InputMaybe<Array<TodoWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<TodoWhereInput>;
  or?: InputMaybe<Array<TodoWhereInput>>;
  /** priority field predicates */
  priority?: InputMaybe<Scalars['Int']['input']>;
  priorityGT?: InputMaybe<Scalars['Int']['input']>;
  priorityGTE?: InputMaybe<Scalars['Int']['input']>;
  priorityIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  priorityLT?: InputMaybe<Scalars['Int']['input']>;
  priorityLTE?: InputMaybe<Scalars['Int']['input']>;
  priorityNEQ?: InputMaybe<Scalars['Int']['input']>;
  priorityNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** status field predicates */
  status?: InputMaybe<TodoStatus>;
  statusIn?: InputMaybe<Array<TodoStatus>>;
  statusNEQ?: InputMaybe<TodoStatus>;
  statusNotIn?: InputMaybe<Array<TodoStatus>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDContains?: InputMaybe<Scalars['ID']['input']>;
  userIDContainsFold?: InputMaybe<Scalars['ID']['input']>;
  userIDEqualFold?: InputMaybe<Scalars['ID']['input']>;
  userIDGT?: InputMaybe<Scalars['ID']['input']>;
  userIDGTE?: InputMaybe<Scalars['ID']['input']>;
  userIDHasPrefix?: InputMaybe<Scalars['ID']['input']>;
  userIDHasSuffix?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  userIDLT?: InputMaybe<Scalars['ID']['input']>;
  userIDLTE?: InputMaybe<Scalars['ID']['input']>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UpdateProfileInput = {
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  sourceFile?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  urn?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateTodoInput = {
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<TodoStatus>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

export type UpdateUserInput = {
  age?: InputMaybe<Scalars['Int']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};

export type User = Node & {
  age: Scalars['Int']['output'];
  createdAt: Scalars['String']['output'];
  email: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  todos: Array<Todo>;
  updatedAt: Scalars['String']['output'];
};

export type UserConnection = {
  edges: Maybe<Array<Maybe<UserEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type UserEdge = {
  cursor: Scalars['Cursor']['output'];
  node: Maybe<User>;
};

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  /** age field predicates */
  age?: InputMaybe<Scalars['Int']['input']>;
  ageGT?: InputMaybe<Scalars['Int']['input']>;
  ageGTE?: InputMaybe<Scalars['Int']['input']>;
  ageIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  ageLT?: InputMaybe<Scalars['Int']['input']>;
  ageLTE?: InputMaybe<Scalars['Int']['input']>;
  ageNEQ?: InputMaybe<Scalars['Int']['input']>;
  ageNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  and?: InputMaybe<Array<UserWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']['input']>;
  emailContains?: InputMaybe<Scalars['String']['input']>;
  emailContainsFold?: InputMaybe<Scalars['String']['input']>;
  emailEqualFold?: InputMaybe<Scalars['String']['input']>;
  emailGT?: InputMaybe<Scalars['String']['input']>;
  emailGTE?: InputMaybe<Scalars['String']['input']>;
  emailHasPrefix?: InputMaybe<Scalars['String']['input']>;
  emailHasSuffix?: InputMaybe<Scalars['String']['input']>;
  emailIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emailLT?: InputMaybe<Scalars['String']['input']>;
  emailLTE?: InputMaybe<Scalars['String']['input']>;
  emailNEQ?: InputMaybe<Scalars['String']['input']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** todos edge predicates */
  hasTodos?: InputMaybe<Scalars['Boolean']['input']>;
  hasTodosWith?: InputMaybe<Array<TodoWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
};

export type AuthPayloadFragment = { accessToken: string, refreshToken: string, user: { id: string, name: string, email: string } };

export type PageInfoFragment = { hasNextPage: boolean, hasPreviousPage: boolean, startCursor: string | null, endCursor: string | null };

export type ProfileFragment = { id: string, name: string, title: string, urn: string };

export type ProfileTitleGroupFragment = { title: string, count: number };

export type RefreshTokenFragmentFragment = { accessToken: string, refreshToken: string };

export type UserFragment = { id: string, name: string, email: string };

export type LoginMutationVariables = Exact<{
  input: LoginInput;
}>;


export type LoginMutation = { login: { accessToken: string, refreshToken: string, user: { id: string, name: string, email: string } } | null };

export type RefreshTokenMutationVariables = Exact<{ [key: string]: never; }>;


export type RefreshTokenMutation = { refreshToken: { accessToken: string, refreshToken: string } | null };

export type GroupProfilesByTitleQueryVariables = Exact<{
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  minCount: Scalars['Int']['input'];
}>;


export type GroupProfilesByTitleQuery = { profilesByTitle: Array<{ title: string, count: number }> };

export type ProfilesQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ProfileWhereInput>;
}>;


export type ProfilesQuery = { profiles: { totalCount: number, edges: Array<{ node: { id: string, name: string, title: string, urn: string } | null } | null> | null, pageInfo: { hasNextPage: boolean, hasPreviousPage: boolean, startCursor: string | null, endCursor: string | null } } | null };

export type UsersQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserWhereInput>;
}>;


export type UsersQuery = { users: { totalCount: number, edges: Array<{ node: { id: string, name: string, email: string } | null } | null> | null, pageInfo: { hasNextPage: boolean, hasPreviousPage: boolean, startCursor: string | null, endCursor: string | null } } | null };
